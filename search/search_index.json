{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"RERUM","text":"<p>Rewriting Expressions via Rules Using Morphisms</p> <p>A pattern matching and term rewriting library for symbolic computation in Python.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Declarative Rules - Define rewrite rules in a simple DSL</li> <li>Pattern Matching - Match expressions with variables, constants, and rest patterns</li> <li>Conditional Guards - Rules with <code>when</code> conditions</li> <li>Rule Priorities - Control which rules fire first</li> <li>Named Groups - Organize rules into selectable groups</li> <li>Multiple Strategies - exhaustive, once, bottomup, topdown</li> <li>CLI &amp; REPL - Interactive exploration and scripting</li> <li>Extensible - Custom preludes for new operations</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from rerum import RuleEngine, E\n\nengine = RuleEngine.from_dsl('''\n    @add-zero: (+ ?x 0) =&gt; :x\n    @mul-one: (* ?x 1) =&gt; :x\n''')\n\nengine(E(\"(+ y 0)\"))  # =&gt; \"y\"\nengine(E(\"(* x 1)\"))  # =&gt; \"x\"\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install rerum\n</code></pre>"},{"location":"#command-line","title":"Command Line","text":"<pre><code>$ rerum\nrerum&gt; @add-zero: (+ ?x 0) =&gt; :x\nAdded 1 rule(s)\nrerum&gt; (+ y 0)\ny\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Tutorial introduction</li> <li>DSL Reference - Complete syntax guide</li> <li>CLI - Command-line interface</li> <li>API Reference - Python API</li> <li>Examples - Real-world examples</li> </ul>"},{"location":"api-reference/","title":"API Reference","text":""},{"location":"api-reference/#ruleengine","title":"RuleEngine","text":"<p>The main class for loading and applying rules.</p>"},{"location":"api-reference/#construction","title":"Construction","text":"<pre><code>from rerum import RuleEngine, ARITHMETIC_PRELUDE\n\n# Empty engine\nengine = RuleEngine()\n\n# With prelude\nengine = RuleEngine(fold_funcs=ARITHMETIC_PRELUDE)\n\n# From DSL\nengine = RuleEngine.from_dsl(\"@add-zero: (+ ?x 0) =&gt; :x\")\n\n# From file\nengine = RuleEngine.from_file(\"rules.rules\")\n\n# From Python list\nengine = RuleEngine.from_rules([[[\"+\", [\"?\", \"x\"], 0], [\":\", \"x\"]]])\n</code></pre>"},{"location":"api-reference/#fluent-api","title":"Fluent API","text":"<pre><code>engine = (RuleEngine()\n    .with_prelude(ARITHMETIC_PRELUDE)\n    .load_dsl(\"@add-zero: (+ ?x 0) =&gt; :x\")\n    .load_file(\"more.rules\")\n    .disable_group(\"experimental\"))\n</code></pre>"},{"location":"api-reference/#simplification","title":"Simplification","text":"<pre><code># Basic\nresult = engine(expr)\nresult = engine.simplify(expr)\n\n# With options\nresult = engine(expr, strategy=\"bottomup\", groups=[\"algebra\"])\n\n# With tracing\nresult, trace = engine(expr, trace=True)\n</code></pre>"},{"location":"api-reference/#pattern-matching","title":"Pattern Matching","text":"<pre><code>from rerum import Bindings, NoMatch\n\n# Match returns Bindings or NoMatch\nif bindings := engine.match(\"(+ ?a ?b)\", expr):\n    print(bindings[\"a\"], bindings[\"b\"])\n</code></pre>"},{"location":"api-reference/#rule-application","title":"Rule Application","text":"<pre><code># Apply one rule\nresult, metadata = engine.apply_once(expr)\n\n# Find matching rules\nfor metadata, bindings in engine.rules_matching(expr):\n    print(f\"{metadata.name}: {bindings.to_dict()}\")\n</code></pre>"},{"location":"api-reference/#inspection","title":"Inspection","text":"<pre><code>len(engine)                    # Number of rules\n\"add-zero\" in engine           # Check if rule exists\nrule, meta = engine[\"add-zero\"] # Get by name\nengine.list_rules()            # DSL format strings\nengine.groups()                # All group names\n\nfor rule, meta in engine:\n    print(meta.name)\n</code></pre>"},{"location":"api-reference/#groups","title":"Groups","text":"<pre><code>engine.groups()                # Get all group names\nengine.disable_group(\"name\")   # Disable a group\nengine.enable_group(\"name\")    # Enable a group\n\n# Use specific groups\nengine(expr, groups=[\"algebra\", \"folding\"])\n</code></pre>"},{"location":"api-reference/#combining-engines","title":"Combining Engines","text":"<pre><code># Union\ncombined = engine1 | engine2\nengine1 |= engine2\n\n# Sequencing (phase1 to fixpoint, then phase2)\npipeline = engine1 &gt;&gt; engine2\nresult = pipeline(expr)\n</code></pre>"},{"location":"api-reference/#expression-builder-e","title":"Expression Builder (E)","text":"<pre><code>from rerum import E\n\n# Parse s-expression\nexpr = E(\"(+ x (* 2 y))\")\n\n# Build programmatically\nexpr = E.op(\"+\", \"x\", E.op(\"*\", 2, \"y\"))\n\n# Variables\nx, y = E.vars(\"x\", \"y\")\nexpr = E.op(\"+\", x, y)\n\n# Constants\nn = E.const(42)\n</code></pre>"},{"location":"api-reference/#bindings","title":"Bindings","text":"<pre><code>from rerum import Bindings, NoMatch\n\n# Dict-like access\nbindings[\"x\"]\nbindings.get(\"x\", default)\n\"x\" in bindings\nbindings.to_dict()\n\n# NoMatch is falsy\nif bindings := engine.match(pattern, expr):\n    # matched\n</code></pre>"},{"location":"api-reference/#rewritetrace","title":"RewriteTrace","text":"<pre><code>result, trace = engine(expr, trace=True)\n\n# Properties\ntrace.initial    # Initial expression\ntrace.final      # Final expression\ntrace.steps      # List of RewriteStep\n\n# Formatting\nstr(trace)                  # Verbose\ntrace.format(\"compact\")     # Single line\ntrace.format(\"rules\")       # Just rule names\ntrace.format(\"chain\")       # Step-by-step\n\n# Statistics\nlen(trace)                  # Number of steps\ntrace.summary()             # Brief summary\ntrace.rule_counts()         # Dict of rule -&gt; count\ntrace.rules_applied()       # List of rule names\n\n# Iteration\nfor step in trace:\n    print(step.metadata.name)\n\n# Serialization\ntrace.to_dict()             # JSON-serializable dict\n\n# Boolean\nif trace:  # True if any rules applied\n    ...\n</code></pre>"},{"location":"api-reference/#preludes","title":"Preludes","text":"<pre><code>from rerum import (\n    ARITHMETIC_PRELUDE,  # +, -, *, /, ^\n    MATH_PRELUDE,        # arithmetic + sin, cos, exp, log, sqrt, abs\n    PREDICATE_PRELUDE,   # &gt;, &lt;, =, const?, var?, list?, and, or, not\n    FULL_PRELUDE,        # arithmetic + predicates\n    MINIMAL_PRELUDE,     # +, * only\n    NO_PRELUDE,          # empty\n)\n\n# Helpers for custom preludes\nfrom rerum import nary_fold, binary_only, unary_only\n\nmy_prelude = {\n    \"+\": nary_fold(0, lambda a, b: a + b),\n    \"max\": binary_only(max),\n    \"neg\": unary_only(lambda x: -x),\n}\n</code></pre>"},{"location":"api-reference/#low-level-functions","title":"Low-Level Functions","text":"<pre><code>from rerum import (\n    match,        # Pattern matching\n    instantiate,  # Skeleton instantiation\n    rewriter,     # Create simplifier function\n    parse_sexpr,  # Parse s-expression string\n    format_sexpr, # Format to s-expression string\n)\n\n# Direct pattern matching\nbindings = match(pattern, expr, [])\nif bindings != \"failed\":\n    result = instantiate(skeleton, bindings, fold_funcs)\n\n# Create rewriter function\nsimplify = rewriter(rules, fold_funcs=ARITHMETIC_PRELUDE)\nresult = simplify(expr)\n\n# S-expression I/O\nexpr = parse_sexpr(\"(+ x 1)\")\ntext = format_sexpr(expr)\n</code></pre>"},{"location":"cli/","title":"Command-Line Interface","text":"<p>RERUM includes a CLI for interactive use and scripting.</p>"},{"location":"cli/#modes","title":"Modes","text":""},{"location":"cli/#repl-mode","title":"REPL Mode","text":"<p>Start an interactive session:</p> <pre><code>$ rerum\nrerum&gt; @add-zero: (+ ?x 0) =&gt; :x\nAdded 1 rule(s)\nrerum&gt; (+ y 0)\ny\nrerum&gt; :quit\n</code></pre>"},{"location":"cli/#script-mode","title":"Script Mode","text":"<p>Run a <code>.rerum</code> script:</p> <pre><code>$ rerum script.rerum\n</code></pre> <p>Scripts support shebang:</p> <pre><code>#!/usr/bin/env rerum\n:prelude full\n@add-zero: (+ ?x 0) =&gt; :x\n(+ x 0)\n</code></pre> <pre><code>$ chmod +x script.rerum\n$ ./script.rerum\nx\n</code></pre>"},{"location":"cli/#expression-mode","title":"Expression Mode","text":"<p>Evaluate a single expression:</p> <pre><code>$ rerum -r rules.rules -p full -e \"(+ x 0)\"\nx\n</code></pre>"},{"location":"cli/#pipe-mode","title":"Pipe Mode","text":"<p>Process stdin:</p> <pre><code>$ echo \"(+ x 0)\" | rerum -r rules.rules -p full -q\nx\n\n$ cat expressions.txt | rerum -r rules.rules -q\n</code></pre>"},{"location":"cli/#command-line-options","title":"Command-Line Options","text":"<pre><code>rerum [script]              Run script or start REPL\n\nOptions:\n  -r, --rules FILE          Load rules from file (repeatable)\n  -e, --expr EXPR           Evaluate single expression\n  -p, --prelude NAME        Set prelude\n  -t, --trace               Enable tracing\n  -s, --strategy NAME       Set strategy\n  -q, --quiet               Suppress non-essential output\n  --version                 Show version\n  -h, --help                Show help\n</code></pre>"},{"location":"cli/#prelude-options","title":"Prelude Options","text":"Name Description <code>none</code> No computation (default) <code>arithmetic</code> <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code> <code>math</code> Arithmetic + trig/exp/log <code>full</code> Arithmetic + predicates <code>path.py</code> Load custom prelude"},{"location":"cli/#strategy-options","title":"Strategy Options","text":"Name Description <code>exhaustive</code> Repeat until fixpoint (default) <code>once</code> Apply at most one rule <code>bottomup</code> Children before parent <code>topdown</code> Parent before children"},{"location":"cli/#repl-commands","title":"REPL Commands","text":"Command Description <code>:help</code> Show help <code>:load FILE</code> Load rules from file <code>:rules</code> List loaded rules <code>:clear</code> Clear all rules <code>:prelude NAME</code> Set prelude <code>:trace on/off</code> Toggle tracing <code>:strategy NAME</code> Set strategy <code>:groups</code> Show all groups <code>:enable GROUP</code> Enable a group <code>:disable GROUP</code> Disable a group <code>:quit</code> Exit"},{"location":"cli/#script-format","title":"Script Format","text":"<p>Scripts can contain:</p> <ul> <li>Comments: Lines starting with <code>#</code></li> <li>Directives: Lines starting with <code>:</code></li> <li>Rules: Lines containing <code>=&gt;</code></li> <li>Groups: Lines like <code>[groupname]</code></li> <li>Expressions: Everything else (printed to stdout)</li> </ul> <pre><code>#!/usr/bin/env rerum\n# My script\n\n:prelude full\n:load base.rules\n\n[local]\n@custom: (f ?x) =&gt; (g :x)\n\n# Evaluate these expressions\n(+ 1 2)\n(f a)\n</code></pre>"},{"location":"cli/#custom-preludes","title":"Custom Preludes","text":"<p>Create a Python file with a <code>PRELUDE</code> dict:</p> <pre><code># my_prelude.py\nfrom rerum import binary_only, unary_only\nimport math\n\nPRELUDE = {\n    \"gcd\": binary_only(math.gcd),\n    \"factorial\": unary_only(math.factorial),\n    \"even?\": unary_only(lambda x: x % 2 == 0),\n}\n</code></pre> <p>Use it:</p> <pre><code>$ rerum -p my_prelude.py -r rules.rules\n</code></pre> <p>Or in scripts:</p> <pre><code>:prelude my_prelude.py\n</code></pre>"},{"location":"cli/#examples","title":"Examples","text":""},{"location":"cli/#interactive-algebra","title":"Interactive Algebra","text":"<pre><code>$ rerum -r algebra.rules -p full\nrerum&gt; (+ (* 2 3) (* 4 5))\n26\nrerum&gt; (+ x 0)\nx\n</code></pre>"},{"location":"cli/#batch-processing","title":"Batch Processing","text":"<pre><code>$ cat &lt;&lt; EOF | rerum -r algebra.rules -p full -q\n(+ 1 2)\n(* 3 4)\n(+ x 0)\nEOF\n3\n12\nx\n</code></pre>"},{"location":"cli/#traced-simplification","title":"Traced Simplification","text":"<pre><code>$ rerum -r algebra.rules -p full -t -e \"(+ (* x 1) 0)\"\nx\nadd-zero -&gt; mul-one\n</code></pre>"},{"location":"dsl-reference/","title":"DSL Reference","text":"<p>Complete reference for RERUM's rule definition language.</p>"},{"location":"dsl-reference/#rule-syntax","title":"Rule Syntax","text":"<pre><code>@name: (pattern) =&gt; (skeleton)\n@name[priority]: (pattern) =&gt; (skeleton)\n@name \"description\": (pattern) =&gt; (skeleton)\n@name[priority] \"description\": (pattern) =&gt; (skeleton)\n@name: (pattern) =&gt; (skeleton) when (condition)\n</code></pre>"},{"location":"dsl-reference/#examples","title":"Examples","text":"<pre><code># Simple rule\n@add-zero: (+ ?x 0) =&gt; :x\n\n# With priority (higher fires first)\n@specific[100]: (+ 0 ?x) =&gt; :x\n\n# With description\n@add-zero \"x + 0 = x\": (+ ?x 0) =&gt; :x\n\n# With guard condition\n@abs-pos: (abs ?x) =&gt; :x when (! &gt; :x 0)\n</code></pre>"},{"location":"dsl-reference/#pattern-syntax","title":"Pattern Syntax","text":""},{"location":"dsl-reference/#basic-patterns","title":"Basic Patterns","text":"Syntax Meaning Example Match <code>?x</code> Match anything <code>(+ ?x 0)</code> matches <code>(+ y 0)</code> <code>?x:expr</code> Same as <code>?x</code> - <code>literal</code> Match exact value <code>0</code> matches <code>0</code> <code>(op ...)</code> Match compound <code>(+ ?x ?y)</code> matches <code>(+ a b)</code>"},{"location":"dsl-reference/#type-constraints","title":"Type Constraints","text":"Syntax Matches Example <code>?x:const</code> Numbers only <code>?n:const</code> matches <code>42</code> <code>?x:var</code> Symbols only <code>?v:var</code> matches <code>x</code> <code>?x:free(v)</code> Not containing <code>v</code> <code>?f:free(x)</code> matches <code>(+ y z)</code>"},{"location":"dsl-reference/#rest-patterns","title":"Rest Patterns","text":"Syntax Meaning Example <code>?xs...</code> Match remaining args <code>(+ ?a ?rest...)</code> <code>?xs:const...</code> Rest, all constants <code>(+ ?nums:const...)</code> <code>?xs:var...</code> Rest, all variables <code>(list ?vars:var...)</code>"},{"location":"dsl-reference/#skeleton-syntax","title":"Skeleton Syntax","text":""},{"location":"dsl-reference/#substitution","title":"Substitution","text":"Syntax Meaning <code>:x</code> Substitute bound value <code>:xs...</code> Splice list into position <code>literal</code> Use as-is"},{"location":"dsl-reference/#computation","title":"Computation","text":"<pre><code>(! op arg1 arg2 ...)\n</code></pre> <p>Evaluates <code>op</code> with arguments using the prelude:</p> <pre><code>@fold-add: (+ ?a:const ?b:const) =&gt; (! + :a :b)\n</code></pre>"},{"location":"dsl-reference/#groups","title":"Groups","text":"<pre><code>[groupname]\n@rule1: ...\n@rule2: ...\n\n[another-group]\n@rule3: ...\n</code></pre> <p>Rules after <code>[groupname]</code> belong to that group until another group starts.</p>"},{"location":"dsl-reference/#comments","title":"Comments","text":"<pre><code># This is a comment\n@rule: (+ ?x 0) =&gt; :x  # Inline comments work too\n</code></pre>"},{"location":"dsl-reference/#available-preludes","title":"Available Preludes","text":""},{"location":"dsl-reference/#arithmetic_prelude","title":"ARITHMETIC_PRELUDE","text":"<p>Operations: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code></p>"},{"location":"dsl-reference/#math_prelude","title":"MATH_PRELUDE","text":"<p>Arithmetic plus: <code>sin</code>, <code>cos</code>, <code>tan</code>, <code>exp</code>, <code>log</code>, <code>sqrt</code>, <code>abs</code></p>"},{"location":"dsl-reference/#predicate_prelude","title":"PREDICATE_PRELUDE","text":"<p>Comparisons: <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>=</code>, <code>!=</code> Type checks: <code>const?</code>, <code>var?</code>, <code>list?</code> Logical: <code>and</code>, <code>or</code>, <code>not</code></p>"},{"location":"dsl-reference/#full_prelude","title":"FULL_PRELUDE","text":"<p>Combines ARITHMETIC_PRELUDE and PREDICATE_PRELUDE.</p>"},{"location":"dsl-reference/#complete-example","title":"Complete Example","text":"<pre><code># algebra.rules - Algebraic simplification\n\n[identity]\n@add-zero[100]: (+ ?x 0) =&gt; :x\n@add-zero-left[100]: (+ 0 ?x) =&gt; :x\n@mul-one[100]: (* ?x 1) =&gt; :x\n@mul-zero[100]: (* ?x 0) =&gt; 0\n\n[folding]\n@fold-add: (+ ?a ?b) =&gt; (! + :a :b) when (! and (! const? :a) (! const? :b))\n@fold-mul: (* ?a ?b) =&gt; (! * :a :b) when (! and (! const? :a) (! const? :b))\n\n[simplify]\n@add-same: (+ ?x ?x) =&gt; (* 2 :x)\n@sub-same: (- ?x ?x) =&gt; 0\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>Real-world examples of RERUM usage.</p>"},{"location":"examples/#algebraic-simplification","title":"Algebraic Simplification","text":"<pre><code>from rerum import RuleEngine, E, FULL_PRELUDE\n\nalgebra = (RuleEngine()\n    .with_prelude(FULL_PRELUDE)\n    .load_dsl('''\n        [identity]\n        @add-zero[100]: (+ ?x 0) =&gt; :x\n        @add-zero-left[100]: (+ 0 ?x) =&gt; :x\n        @mul-one[100]: (* ?x 1) =&gt; :x\n        @mul-one-left[100]: (* 1 ?x) =&gt; :x\n        @mul-zero[100]: (* ?x 0) =&gt; 0\n\n        [folding]\n        @fold-add: (+ ?a ?b) =&gt; (! + :a :b) when (! and (! const? :a) (! const? :b))\n        @fold-mul: (* ?a ?b) =&gt; (! * :a :b) when (! and (! const? :a) (! const? :b))\n\n        [simplify]\n        @add-same: (+ ?x ?x) =&gt; (* 2 :x)\n        @sub-same: (- ?x ?x) =&gt; 0\n    '''))\n\nalgebra(E(\"(+ (* x 1) 0)\"))      # =&gt; \"x\"\nalgebra(E(\"(+ 2 3)\"))            # =&gt; 5\nalgebra(E(\"(+ x x)\"))            # =&gt; (* 2 x)\n</code></pre>"},{"location":"examples/#symbolic-differentiation","title":"Symbolic Differentiation","text":"<pre><code>calculus = RuleEngine.from_dsl('''\n    [basic]\n    @dd-const[100]: (dd ?c:const ?v:var) =&gt; 0\n    @dd-var-same[100]: (dd ?x:var ?x) =&gt; 1\n    @dd-var-diff[90]: (dd ?y:var ?x:var) =&gt; 0\n\n    [linear]\n    @dd-sum: (dd (+ ?f ?g) ?v:var) =&gt; (+ (dd :f :v) (dd :g :v))\n    @dd-const-mult: (dd (* ?c:const ?f) ?v:var) =&gt; (* :c (dd :f :v))\n\n    [product]\n    @dd-product: (dd (* ?f ?g) ?v:var) =&gt; (+ (* (dd :f :v) :g) (* :f (dd :g :v)))\n\n    [power]\n    @dd-power: (dd (^ ?f ?n:const) ?v:var) =&gt; (* :n (* (^ :f (- :n 1)) (dd :f :v)))\n''')\n\ncalculus(E(\"(dd x x)\"))              # =&gt; 1\ncalculus(E(\"(dd (^ x 2) x)\"))        # =&gt; (* 2 (* (^ x (- 2 1)) 1))\ncalculus(E(\"(dd (+ x y) x)\"))        # =&gt; (+ 1 0)\n</code></pre>"},{"location":"examples/#phased-processing","title":"Phased Processing","text":"<pre><code># Expand then simplify\nexpand = RuleEngine.from_dsl('''\n    @square: (square ?x) =&gt; (* :x :x)\n    @cube: (cube ?x) =&gt; (* :x (* :x :x))\n''')\n\nsimplify = (RuleEngine()\n    .with_prelude(FULL_PRELUDE)\n    .load_dsl('''\n        @fold: (* ?a ?b) =&gt; (! * :a :b) when (! and (! const? :a) (! const? :b))\n    '''))\n\npipeline = expand &gt;&gt; simplify\n\npipeline(E(\"(square 5)\"))   # =&gt; 25\npipeline(E(\"(cube 3)\"))     # =&gt; 27\n</code></pre>"},{"location":"examples/#boolean-logic","title":"Boolean Logic","text":"<pre><code>logic = RuleEngine.from_dsl('''\n    [identity]\n    @and-true[100]: (and true ?x) =&gt; :x\n    @and-false[100]: (and false ?x) =&gt; false\n    @or-true[100]: (or true ?x) =&gt; true\n    @or-false[100]: (or false ?x) =&gt; :x\n    @not-not[100]: (not (not ?x)) =&gt; :x\n\n    [deMorgan]\n    @demorgan-and: (not (and ?x ?y)) =&gt; (or (not :x) (not :y))\n    @demorgan-or: (not (or ?x ?y)) =&gt; (and (not :x) (not :y))\n\n    [simplify]\n    @and-same: (and ?x ?x) =&gt; :x\n    @or-same: (or ?x ?x) =&gt; :x\n''')\n\nlogic(E(\"(and true x)\"))                # =&gt; x\nlogic(E(\"(not (not p))\"))               # =&gt; p\nlogic(E(\"(not (and a b))\"))             # =&gt; (or (not a) (not b))\n</code></pre>"},{"location":"examples/#lambda-calculus","title":"Lambda Calculus","text":"<pre><code>lambda_calc = RuleEngine.from_dsl('''\n    # Beta reduction (simplified - assumes no capture)\n    @beta: (app (lam ?x ?body) ?arg) =&gt; (subst :body :x :arg)\n\n    # Substitution rules\n    @subst-var-same: (subst ?x ?x ?e) =&gt; :e\n    @subst-var-diff: (subst ?y:var ?x:var ?e) =&gt; :y\n    @subst-const: (subst ?c:const ?x ?e) =&gt; :c\n    @subst-lam: (subst (lam ?y ?body) ?x ?e) =&gt; (lam :y (subst :body :x :e))\n    @subst-app: (subst (app ?f ?a) ?x ?e) =&gt; (app (subst :f :x :e) (subst :a :x :e))\n''')\n\n# (\u03bbx.x) y =&gt; y\nlambda_calc(E(\"(app (lam x x) y)\"))\n\n# (\u03bbx.(\u03bby.x)) a b =&gt; a\nexpr = E(\"(app (app (lam x (lam y x)) a) b)\")\nlambda_calc(expr)\n</code></pre>"},{"location":"examples/#selective-simplification","title":"Selective Simplification","text":"<pre><code>engine = RuleEngine.from_dsl('''\n    [expand]\n    @square: (square ?x) =&gt; (* :x :x)\n\n    [collect]\n    @add-same: (+ ?x ?x) =&gt; (* 2 :x)\n''')\n\nexpr = E(\"(+ (square x) (square x))\")\n\n# Only expand\nengine(expr, groups=[\"expand\"])     # =&gt; (+ (* x x) (* x x))\n\n# Only collect\nengine(expr, groups=[\"collect\"])    # =&gt; (* 2 (square x))\n\n# Both\nengine(expr)                        # =&gt; (* 2 (* x x))\n</code></pre>"},{"location":"examples/#custom-operations","title":"Custom Operations","text":"<pre><code># my_prelude.py\nfrom rerum import binary_only, unary_only\nimport math\n\nPRELUDE = {\n    \"gcd\": binary_only(math.gcd),\n    \"lcm\": binary_only(math.lcm),\n    \"factorial\": unary_only(math.factorial),\n    \"even?\": unary_only(lambda x: x % 2 == 0),\n    \"odd?\": unary_only(lambda x: x % 2 == 1),\n}\n</code></pre> <pre><code>from my_prelude import PRELUDE\n\nnumber_theory = (RuleEngine()\n    .with_prelude(PRELUDE)\n    .load_dsl('''\n        @eval-gcd: (gcd ?a ?b) =&gt; (! gcd :a :b) when (! and (! const? :a) (! const? :b))\n        @eval-lcm: (lcm ?a ?b) =&gt; (! lcm :a :b) when (! and (! const? :a) (! const? :b))\n        @eval-factorial: (factorial ?n) =&gt; (! factorial :n) when (! const? :n)\n\n        @gcd-same: (gcd ?x ?x) =&gt; :x\n        @lcm-same: (lcm ?x ?x) =&gt; :x\n    '''))\n\nnumber_theory(E(\"(gcd 12 8)\"))      # =&gt; 4\nnumber_theory(E(\"(factorial 5)\"))   # =&gt; 120\n</code></pre>"},{"location":"examples/#tracing-derivations","title":"Tracing Derivations","text":"<pre><code>engine = RuleEngine.from_dsl('''\n    @add-zero: (+ ?x 0) =&gt; :x\n    @mul-one: (* ?x 1) =&gt; :x\n    @mul-zero: (* ?x 0) =&gt; 0\n''')\n\nresult, trace = engine(E(\"(+ (* (* x 0) 1) 0)\"), trace=True)\n\nprint(trace)\n# Initial: (+ (* (* x 0) 1) 0)\n#   1. mul-zero: (* x 0) \u2192 0\n#   2. mul-one: (* 0 1) \u2192 0\n#   3. add-zero: (+ 0 0) \u2192 0\n# Final: 0\n\nprint(trace.format(\"compact\"))\n# (+ (* (* x 0) 1) 0) --[mul-zero, mul-one, add-zero]--&gt; 0\n\nprint(trace.summary())\n# 3 steps using 3 unique rules. Most used: mul-zero (1x)\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide introduces RERUM's core concepts through examples.</p>"},{"location":"getting-started/#expressions","title":"Expressions","text":"<p>RERUM works with s-expressions - nested lists in prefix notation:</p> <pre><code>from rerum import E\n\n# Parse s-expression strings\nexpr = E(\"(+ x (* 2 y))\")  # =&gt; [\"+\", \"x\", [\"*\", 2, \"y\"]]\n\n# Build programmatically\nexpr = E.op(\"+\", \"x\", E.op(\"*\", 2, \"y\"))\n\n# Create variables\nx, y = E.vars(\"x\", \"y\")\n</code></pre>"},{"location":"getting-started/#rules","title":"Rules","text":"<p>Rules transform expressions. A rule has a pattern (what to match) and a skeleton (what to produce):</p> <pre><code>from rerum import RuleEngine\n\nengine = RuleEngine.from_dsl('''\n    @add-zero: (+ ?x 0) =&gt; :x\n''')\n\nengine(E(\"(+ y 0)\"))  # =&gt; \"y\"\n</code></pre> <ul> <li><code>?x</code> matches any expression and binds it to <code>x</code></li> <li><code>:x</code> substitutes the bound value</li> </ul>"},{"location":"getting-started/#pattern-types","title":"Pattern Types","text":"Pattern Matches <code>?x</code> Any expression <code>?x:const</code> Numbers only <code>?x:var</code> Symbols only <code>?x:free(v)</code> Expressions not containing <code>v</code> <code>?x...</code> Rest of arguments"},{"location":"getting-started/#computation","title":"Computation","text":"<p>The <code>(! op args...)</code> form evaluates operations:</p> <pre><code>from rerum import RuleEngine, ARITHMETIC_PRELUDE\n\nengine = (RuleEngine()\n    .with_prelude(ARITHMETIC_PRELUDE)\n    .load_dsl('''\n        @fold: (+ ?a:const ?b:const) =&gt; (! + :a :b)\n    '''))\n\nengine(E(\"(+ 2 3)\"))  # =&gt; 5\n</code></pre> <p>Note</p> <p><code>(! ...)</code> only evaluates when the prelude defines the operation. Without a prelude, it remains symbolic.</p>"},{"location":"getting-started/#conditional-guards","title":"Conditional Guards","text":"<p>Rules can have conditions:</p> <pre><code>from rerum import FULL_PRELUDE\n\nengine = (RuleEngine()\n    .with_prelude(FULL_PRELUDE)\n    .load_dsl('''\n        @abs-pos: (abs ?x) =&gt; :x when (! &gt; :x 0)\n        @abs-neg: (abs ?x) =&gt; (! - 0 :x) when (! &lt; :x 0)\n    '''))\n\nengine(E(\"(abs -5)\"))  # =&gt; 5\n</code></pre>"},{"location":"getting-started/#priorities","title":"Priorities","text":"<p>Higher priority rules fire first:</p> <pre><code>engine = RuleEngine.from_dsl('''\n    @general: (f ?x) =&gt; (g :x)\n    @specific[100]: (f 0) =&gt; zero\n''')\n\nengine(E(\"(f 0)\"))  # =&gt; \"zero\" (specific wins)\n</code></pre>"},{"location":"getting-started/#groups","title":"Groups","text":"<p>Organize rules into named groups:</p> <pre><code>engine = RuleEngine.from_dsl('''\n    [algebra]\n    @add-zero: (+ ?x 0) =&gt; :x\n\n    [expand]\n    @square: (square ?x) =&gt; (* :x :x)\n''')\n\n# Use only algebra rules\nengine(E(\"(+ x 0)\"), groups=[\"algebra\"])\n\n# Disable a group\nengine.disable_group(\"expand\")\n</code></pre>"},{"location":"getting-started/#strategies","title":"Strategies","text":"<p>Control how rules are applied:</p> <pre><code># exhaustive (default): repeat until no rules match\nengine(expr, strategy=\"exhaustive\")\n\n# once: apply at most one rule\nengine(expr, strategy=\"once\")\n\n# bottomup: simplify children first\nengine(expr, strategy=\"bottomup\")\n\n# topdown: try parent first\nengine(expr, strategy=\"topdown\")\n</code></pre>"},{"location":"getting-started/#tracing","title":"Tracing","text":"<p>See which rules fire:</p> <pre><code>result, trace = engine(expr, trace=True)\nprint(trace)\nprint(trace.format(\"compact\"))\nprint(trace.rules_applied())\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>DSL Reference - Complete syntax</li> <li>CLI - Interactive use</li> <li>Examples - Real-world patterns</li> </ul>"}]}